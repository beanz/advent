#!/usr/bin/perl
use strict;
use warnings;
use v5.34;

# for day 13: aoc-intcode-disas 379 14 639 10000 <input.txt

use constant {
  OP_ADD => 1,
  OP_MUL => 2,
  OP_IN => 3,
  OP_OUT => 4,
  OP_JNZ => 5,
  OP_JZ => 6,
  OP_LT => 7,
  OP_EQ => 8,
  OP_BASE => 9,
  OP_HALT => 99,
};

$_ = <STDIN>;
my @i = m!(-?\d+)!g;

my %skip = @ARGV;
my %prog = (ip => 0, in => \@i, skip => \%skip);
while ($prog{ip} < scalar @{$prog{in}}) {
  decode(\%prog);
}

sub op_str {
  return "halt" if ($_[0] == 99);
  return [qw/noop add mul in out jnz jz lt eq base/]->[$_[0]];
}

sub arity {
  return 0 if ($_[0] == 99);
  return [0, 3, 3, 1, 1, 2, 2, 3, 3, 1]->[$_[0]];
}

sub inst_str {
  my ($p) = @_;
  my $raw = $p->{in}->[$p->{ip}];
  my $op = $raw % 100;
  my $arity = arity($op);
  my (@args) = map {$p->{in}->[$p->{ip} + $_]} (1 .. $arity);
  my (@mode) = map {mode($raw, $_ - 1)} (1 .. $arity);
  my @args_str;
  for my $i (0 .. $arity - 1) {
    push @args_str, arg_str($mode[$i], $args[$i]);
  }
  my $arg_str = join " ", @args_str;
  my $op_str = op_str($op);
  my $extra = "";
  if ($raw == 109) {
    if ($args[0] > 8) {

      # probably initial set rather than stack offset
    } elsif ($args[0] > 0) {
      $extra .= ' sub ***';
    }
  }
  if ( ($raw == 1106 && $args[0] == 0)
    || ($raw == 1105 && $args[0] == 1))
  {
    $op_str = 'jmp';
    $arg_str = $args_str[1];
    $raw = '20';
  } elsif ((($raw == 2106 && $args[0] == 0) || ($raw == 2105 && $args[0] != 0))
    && $args[1] == 0)
  {
    $extra .= " return";
    $op_str = 'ret';
    $arg_str = $args_str[1];
    $raw = '21';
  } elsif ($raw == 1101 || $raw == 21101) {
    $op_str = 'seti';
    $arg_str = 'imm(' . ($args[0] + $args[1]) . ') ' . $args_str[2];
    $raw = '30';
  } elsif ($raw == 1102 || $raw == 21102) {
    $op_str = 'seti';
    $arg_str = 'imm(' . ($args[0] * $args[1]) . ') ' . $args_str[2];
    $raw = '30';
  } elsif (($op == 1 && $mode[0] == 1 && $args[0] == 0)
    || ($op == 2 && $mode[0] == 1 && $args[0] == 1))
  {
    $op_str = 'set';
    $arg_str = join ' ', $args_str[1], $args_str[2];
    $raw = '31';
  } elsif (($op == 1 && $mode[1] == 1 && $args[1] == 0)
    || ($op == 2 && $mode[1] == 1 && $args[1] == 1))
  {
    $op_str = 'set';
    $arg_str = join ' ', $args_str[0], $args_str[2];
    $raw = '31';
  }
  return (sprintf('%5d %-4s %s%s', $raw, $op_str, $arg_str, $extra), $arity);
}

sub mode {
  my ($raw, $i) = @_;
  my $div = [100, 1000, 10000]->[$i];
  int($raw / $div) % 10;
}

sub mode_str {
  [qw/pos imm rel/]->[$_[0]];
}

sub arg_str {
  my ($mode, $arg) = @_;
  mode_str($mode) . "(" . $arg . ")";
}

sub decode {
  my ($p) = @_;
  my $skip = $p->{skip}->{$p->{ip}};
  if ($skip) {

    # printf "%5d: skipping %d\n", $p->{ip}, $skip;
    for my $j (0 .. ($skip - 1)) {
      my $da = $p->{ip} + $j;
      next unless ($da < scalar @{$p->{in}});
      printf "%5d: data %d\n", $da, $p->{in}->[$da];
    }
    $p->{ip} += $skip;
    return;
  }
  my ($str, $arity) = inst_str($p);
  printf "%5d: %s\n", $p->{ip}, $str;
  $p->{ip} += 1 + $arity;
}
